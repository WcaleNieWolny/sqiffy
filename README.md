# Sqiffy 

**sqiffy** _(or just squiffy üçπ)_ - Compound **SQ**L framework with type-safe DSL API generated at compile-time from scheme d**iff**.
It is dedicated for applications, plugins & libraries responsible for internal database management.

### What it does?

1. User defines versioned table definition using `@Defintion` annotation 
2. Sqiffy's annotation processor (KSP) at compile-time:
   1. Converts table definitions into versioned changelog, similar to [Liquibase](https://github.com/liquibase/liquibase)
   2. Generates up-to-date entity data classes for Kotlin with [KotlinPoet](https://github.com/square/kotlinpoet)
   3. Creates bindings for [Exposed (<ins>DSL</ins>)](https://github.com/JetBrains/Exposed) framework
3. When application starts, you can run set of prepared versioned migrations against current database state

### Supports

* MySQL/MariaDB
* H2 (MySQL Mode)

### How to use

Describe your table using versioned definitions:

```kotlin
object Versions {
    const val V_1_0_0 = "1.0.0"
    const val V_1_0_1 = "1.0.1"
    const val V_1_0_2 = "1.0.2"
}

@Definition([
    DefinitionVersion(
        version = V_1_0_0,
        name = "users_table",
        properties = [
            Property(name = "id", type = INT, autoincrement = true),
            Property(name = "uuid", type = UUID_VARCHAR),
            Property(name = "name", type = VARCHAR, details = "12"),
        ],
        constraints = [
            Constraint(type = PRIMARY_KEY, name = "pk_id", on = "id"),
        ],
        indices = [
            Index(type = INDEX, name = "idx_id", columns = ["id"]),
            Index(type = UNIQUE_INDEX, name = "uq_name", columns = ["name"])
        ]
    ),
    DefinitionVersion(
        version = V_1_0_1,
        properties = [
            Property(operation = RETYPE, name = "name", type = VARCHAR, details = "24"),
            Property(name = "display_name", type = VARCHAR, details = "48", nullable = true)
        ],
        indices = [
            Index(operation = REMOVE_INDEX, type = INDEX, name = "idx_id"),
            Index(type = INDEX, name = "idx_id", columns = ["id"])
        ]
    ),
    DefinitionVersion(
        version = V_1_0_2,
        properties = [
            Property(operation = RENAME, name = "display_name", rename = "displayName")
        ]
    )
])
object UserDefinition

@Definition([
    DefinitionVersion(
        version = V_1_0_0,
        name = "guilds_table",
        properties = [
            Property(name = "id", type = INT, autoincrement = true),
            Property(name = "owner", type = INT)
        ],
        constraints = [
            Constraint(type = FOREIGN_KEY, on = "id", name = "fk_id", referenced = UserDefinition::class, references = "id")
        ]
    ),
    DefinitionVersion(
        version = V_1_0_1,
        constraints = [
            Constraint(REMOVE_CONSTRAINT, type = FOREIGN_KEY, name = "fk_id")
        ]
    ),
    DefinitionVersion(
        version = V_1_0_2,
        constraints = [
            Constraint(type = FOREIGN_KEY, on = "id", name = "fk_id", referenced = UserDefinition::class, references = "id")
        ]
    )
])
object GuildDefinition
```

Build your project, so KSP can generate classes on top of the specified changelog. 
In this case it'll generate:

* `User`, `Guild` data class
* `UserTable`, `GuildTable` implementation of Exposed's `Table` object
* SQL migrations between each version

Then, you can simply connect to the database, run migrations & use DSL:

```kotlin
val sqiffy = Sqiffy(
    dataSource = createHikariDataSource(
        driver = "org.h2.Driver",
        url = "jdbc:h2:${createTestDatabaseFile("test-database").absolutePathString()};MODE=MYSQL",
        threadPool = 1
    ),
    logger = Slf4JSqiffyLogger(LoggerFactory.getLogger(Sqiffy::class.java))
)

// read current version from `sqiffy_scheme_version` table and run missing migrations
sqiffy.transaction {
    val changeLog = sqiffy.generateChangeLog(UserDefinition::class, GuildDefinition::class)
    sqiffy.runMigrations(changeLog)
}

// save entity with generated exposed dsl bindings
sqiffy.transaction {
    // generated by sqiffy entity with named fields
    val user = User(
        id = 69,
        name = "Panda",
        uuid = UUID.randomUUID(),
        displayName = "Sadge"
    )

    UserTable.insert {
        it[UserTable.id] = user.id
        it[UserTable.name] = user.name
        it[UserTable.uuid] = user.uuid
        it[UserTable.displayName] = user.displayName
    }
}

// read entity from database with generated exposed dsl bindings
val userFromDatabase = sqiffy.transaction {
    UserTable.select { UserTable.name eq "Panda" }
        .first()
        .let {
            User(
                id = it[UserTable.id],
                name = it[UserTable.name],
                uuid = it[UserTable.uuid],
                displayName = it[UserTable.displayName]
            )
        }
}

println(userFromDatabase)
sqiffy.close()
```